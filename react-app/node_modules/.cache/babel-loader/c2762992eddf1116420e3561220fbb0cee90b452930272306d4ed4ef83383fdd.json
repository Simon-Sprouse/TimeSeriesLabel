{"ast":null,"code":"var _jsxFileName = \"/Users/simonsprouse/Desktop/Rev/TimeSeriesLabel/my-app/src/Graph.js\",\n  _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction Graph() {\n  _s();\n  const canvasRef = useRef(null);\n  const [verticalLines, setVerticalLines] = useState([]);\n  const [dataPoints, setDataPoints] = useState(Array.from({\n    length: 20\n  }, () => [0, 0, 0]));\n  function addVeriticalLine(event) {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    setVerticalLines(prevLines => {\n      const newLines = [...prevLines, x].sort((a, b) => a - b);\n      setDataPoints(prevDataPoints => {\n        const updatedPoints = updatePointIds(newLines, prevDataPoints);\n        return updatedPoints;\n      });\n      return newLines;\n    });\n  }\n  function updatePointIds(verticalLines, dataPoints) {\n    const canvas = canvasRef.current;\n    const x_step = canvas.width / (dataPoints.length - 1);\n    dataPoints.forEach(point => console.log(point));\n    const updatedPoints = dataPoints.map((point, index) => {\n      const x = x_step * index; // x pos on graph\n      let newId = 0;\n      for (let i = 0; i < verticalLines.length; i++) {\n        if (x > verticalLines[i]) {\n          newId = i + 1;\n        } else {\n          break;\n        }\n      }\n      return [point[0], newId, point[2]];\n    });\n\n    // updatedPoints.forEach(point => console.log(point));\n\n    setDataPoints(updatedPoints);\n  }\n  function drawGraph() {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const x_step = canvas.width / (dataPoints.length - 1);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.moveTo(0, dataPoints[0][0]);\n    ctx.strokeStyle = \"blue\";\n    ctx.lineWidth = 2;\n\n    // draw datapoints graph\n    dataPoints.forEach((point, index) => {\n      const x = index * x_step;\n      const price = point[0];\n      const color = point[2];\n      if (color == 0) {\n        ctx.strokeStyle = \"blue\";\n      } else if (color == 1) {\n        ctx.strokeStyle = \"red\";\n      }\n      ctx.lineTo(x, price);\n      ctx.stroke();\n    });\n\n    // draw vertical lines\n    verticalLines.forEach(line => {\n      ctx.beginPath();\n      ctx.moveTo(line, 0);\n      ctx.lineTo(line, canvas.height);\n      ctx.strokeStyle = \"black\";\n      ctx.linewidth = 2;\n      ctx.stroke();\n    });\n  }\n\n  // populate array with data\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const initialData = Array.from({\n      length: 20\n    }, () => [Math.random() * canvas.height, 0, 0]);\n    setDataPoints(initialData);\n  }, []);\n\n  // draw graph\n  useEffect(() => {\n    console.log(\"detected a change in dataPoints\");\n    drawGraph();\n  }, [verticalLines, dataPoints]);\n\n  // add event listener to graph\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    canvas.addEventListener(\"click\", addVeriticalLine);\n    return () => {\n      canvas.removeEventListener(\"click\", addVeriticalLine);\n    };\n  }, []);\n  function handleClick() {\n    console.log(dataPoints);\n  }\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"graph\",\n      ref: canvasRef,\n      width: \"800\",\n      height: \"400\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleClick,\n      children: \"Log\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true);\n}\n_s(Graph, \"GSHoszKXT43QGMuLWIrl3cxh5WM=\");\n_c = Graph;\nexport default Graph;\n\n/*\n\n\nOk Here's what the fuck is happening. \n\nSo right now the lines get drawn but aren't stored anywhere. \n\nI need the data array to contain three items per point: \n    - price\n    - id\n    - class\n\nso the array should look like: \n\n    [[58, 0, 1], [50, 0, 1], [60, 1, 3]]\n\nPrice should be generated randomly for now. \nId will be unique for each section bounded by vertical lines\nClass will be generated randomly for now 0-k\n\n\n*/\nvar _c;\n$RefreshReg$(_c, \"Graph\");","map":{"version":3,"names":["useState","useEffect","useRef","jsxDEV","_jsxDEV","Fragment","_Fragment","Graph","_s","canvasRef","verticalLines","setVerticalLines","dataPoints","setDataPoints","Array","from","length","addVeriticalLine","event","canvas","current","ctx","getContext","rect","getBoundingClientRect","x","clientX","left","prevLines","newLines","sort","a","b","prevDataPoints","updatedPoints","updatePointIds","x_step","width","forEach","point","console","log","map","index","newId","i","drawGraph","clearRect","height","beginPath","moveTo","strokeStyle","lineWidth","price","color","lineTo","stroke","line","linewidth","initialData","Math","random","addEventListener","removeEventListener","handleClick","children","id","ref","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/simonsprouse/Desktop/Rev/TimeSeriesLabel/my-app/src/Graph.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react'\n\nfunction Graph() { \n\n    const canvasRef = useRef(null);\n\n    const [verticalLines, setVerticalLines] = useState([]);\n    const [dataPoints, setDataPoints] = useState(Array.from({length: 20}, () => [0, 0, 0]));\n\n    function addVeriticalLine(event) { \n        \n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        \n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n\n\n        setVerticalLines(prevLines => {\n            const newLines = [...prevLines, x].sort((a, b) => a - b);\n            setDataPoints(prevDataPoints => { \n                const updatedPoints = updatePointIds(newLines, prevDataPoints);\n                return updatedPoints;\n            })\n            return newLines;\n        });\n\n    }\n\n\n    function updatePointIds(verticalLines, dataPoints) { \n        const canvas = canvasRef.current;\n        const x_step = canvas.width / (dataPoints.length - 1);\n\n        dataPoints.forEach(point => console.log(point));\n\n        const updatedPoints = dataPoints.map((point, index) => { \n            const x = x_step * index; // x pos on graph\n            let newId = 0;\n\n            for (let i = 0; i < verticalLines.length; i++) {\n                if (x > verticalLines[i]) { \n                    newId = i + 1;\n                }\n                else { \n                    break;\n                }\n            }\n\n            return [point[0], newId, point[2]];\n        });\n\n        // updatedPoints.forEach(point => console.log(point));\n\n        setDataPoints(updatedPoints);\n\n    }\n\n\n    function drawGraph() {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n\n        const x_step = canvas.width / (dataPoints.length - 1);\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.beginPath();\n        ctx.moveTo(0, dataPoints[0][0]);\n\n        ctx.strokeStyle = \"blue\";\n        ctx.lineWidth = 2;\n\n        // draw datapoints graph\n        dataPoints.forEach((point, index) => { \n            const x = index * x_step;\n            const price = point[0];\n            const color = point[2];\n\n            if (color == 0) {\n                ctx.strokeStyle = \"blue\";\n            }\n            else if (color == 1) {\n                ctx.strokeStyle = \"red\";\n            }\n\n            ctx.lineTo(x, price);\n            ctx.stroke();\n        });\n\n\n        // draw vertical lines\n        verticalLines.forEach(line => {\n            \n            ctx.beginPath();\n            ctx.moveTo(line, 0);\n            ctx.lineTo(line, canvas.height);\n            ctx.strokeStyle = \"black\";\n            ctx.linewidth = 2;\n            ctx.stroke();\n        })\n    }\n\n\n    // populate array with data\n    useEffect(() => { \n        const canvas = canvasRef.current;\n        const initialData = Array.from({length: 20}, () => [Math.random() * canvas.height, 0, 0])\n        setDataPoints(initialData);\n    }, []);\n\n\n    // draw graph\n    useEffect(() => { \n        console.log(\"detected a change in dataPoints\");\n        drawGraph();\n    }, [verticalLines, dataPoints]);\n\n\n    // add event listener to graph\n    useEffect(() => { \n        const canvas = canvasRef.current;\n        canvas.addEventListener(\"click\", addVeriticalLine);\n\n        return () => { \n            canvas.removeEventListener(\"click\", addVeriticalLine);\n        }\n    }, []);\n\n\n    function handleClick() {\n        console.log(dataPoints);\n    }\n\n\n\n    return (\n        <>\n            <canvas id=\"graph\" ref={canvasRef} width=\"800\" height=\"400\"></canvas>\n            <button onClick={handleClick}>Log</button>\n        </>\n    )\n}\n\nexport default Graph;\n\n\n\n\n\n\n\n\n/*\n\n\nOk Here's what the fuck is happening. \n\nSo right now the lines get drawn but aren't stored anywhere. \n\nI need the data array to contain three items per point: \n    - price\n    - id\n    - class\n\nso the array should look like: \n\n    [[58, 0, 1], [50, 0, 1], [60, 1, 3]]\n\nPrice should be generated randomly for now. \nId will be unique for each section bounded by vertical lines\nClass will be generated randomly for now 0-k\n\n\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}