{"ast":null,"code":"var _jsxFileName = \"/Users/simonsprouse/Desktop/Rev/TimeSeriesLabel/GitHubProject/TimeSeriesLabel/react-app/src/Graph.js\",\n  _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction Graph(dataFromCsv) {\n  _s();\n  // Variables\n  const canvasRef = useRef(null);\n  const [mode, setMode] = useState(\"Split\");\n  const [verticalLines, setVerticalLines] = useState([]);\n  const initialData = Array.from({\n    length: 300\n  }, () => [0, 0, 0]);\n  const [dataPoints, setDataPoints] = useState(initialData);\n\n  // Load data from prop\n  useEffect(() => {\n    const adjustedData = dataFromCsv['dataFromCsv'];\n    setDataPoints(adjustedData);\n  }, [dataFromCsv]);\n\n  /*\n  ------------------------\n          Edit Mode\n  ------------------------\n  */\n\n  function getClickedId(event) {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const x_step = canvas.width / (dataPoints.length - 1);\n    const index = Math.floor(x / x_step);\n    const pointId = dataPoints[index][1];\n    return pointId;\n  }\n  function updateColorById(id) {\n    const updatedPoints = dataPoints.map(point => {\n      const pointId = point[1];\n      if (pointId == id) {\n        return [point[0], point[1], point[2] + 1];\n      }\n      return point;\n    });\n    setDataPoints(updatedPoints);\n  }\n\n  /*\n  ------------------------\n         Segment Mode\n  ------------------------\n  */\n\n  function addVeriticalLine(event) {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    setVerticalLines(prevLines => {\n      const newLines = [...prevLines, x].sort((a, b) => a - b);\n      updatePointIds(newLines);\n      return newLines;\n    });\n  }\n  function updatePointIds(verticalLines) {\n    const canvas = canvasRef.current;\n    const x_step = canvas.width / (dataPoints.length - 1);\n\n    // dataPoints.forEach(point => console.log(point));\n\n    const updatedPoints = dataPoints.map((point, index) => {\n      const x = x_step * index; // x pos on graph\n      let newId = 0;\n      for (let i = 0; i < verticalLines.length; i++) {\n        if (x > verticalLines[i]) {\n          newId = i + 1;\n        } else {\n          break;\n        }\n      }\n      return [point[0], newId, point[2]];\n    });\n\n    // updatedPoints.forEach(point => console.log(point));\n\n    setDataPoints(updatedPoints);\n  }\n\n  /*\n  ------------------------\n          Rendering\n  ------------------------\n  */\n\n  function drawGraph() {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const x_step = canvas.width / (dataPoints.length - 1);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.lineWidth = 3;\n\n    // draw datapoints graph\n    dataPoints.forEach((point, index) => {\n      const x = index * x_step;\n      const price = canvas.height - point[0];\n      const id = point[1];\n      const color = point[2];\n      if (index > 0) {\n        const prevX = (index - 1) * x_step;\n        const prevPoint = dataPoints[index - 1];\n        const prevPrice = canvas.height - prevPoint[0];\n        const prevId = prevPoint[1];\n        if (color % 4 == 0) {\n          ctx.strokeStyle = \"blue\";\n        } else if (color % 4 == 1) {\n          ctx.strokeStyle = \"red\";\n        } else if (color % 4 == 2) {\n          ctx.strokeStyle = \"green\";\n        } else if (color % 4 == 3) {\n          ctx.strokeStyle = \"orange\";\n        }\n        ctx.beginPath();\n        ctx.moveTo(prevX, prevPrice);\n        ctx.lineTo(x, price);\n        ctx.stroke();\n      }\n    });\n\n    // draw vertical lines\n    verticalLines.forEach(line => {\n      ctx.beginPath();\n      ctx.moveTo(line, 0);\n      ctx.lineTo(line, canvas.height);\n      ctx.strokeStyle = \"black\";\n      ctx.linewidth = 2;\n      ctx.stroke();\n    });\n  }\n\n  // draw graph\n  useEffect(() => {\n    // console.log(\"detected a change in dataPoints\");\n    drawGraph();\n  }, [verticalLines, dataPoints]);\n\n  /*\n  ------------------------\n              UX\n  ------------------------\n  */\n\n  function handleCanvasClick(event) {\n    if (mode == \"Split\") {\n      addVeriticalLine(event);\n    } else if (mode == \"Edit\") {\n      const id = getClickedId(event);\n      updateColorById(id);\n    }\n  }\n  function toggleMode() {\n    if (mode == \"Split\") {\n      setMode(\"Edit\");\n    } else {\n      setMode(\"Split\");\n    }\n  }\n  function test() {\n    // dataFromCsv.forEach((point, index) => { \n    //     console.log(point, index);\n    // })\n    console.log(dataFromCsv['dataFromCsv']);\n  }\n  document.addEventListener(\"keydown\", event => {\n    if (event.key == \"Enter\") {\n      toggleMode();\n    }\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: mode == \"Split\" ? \"Segment Mode\" : \"Label Mode\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"graph\",\n      ref: canvasRef,\n      onClick: handleCanvasClick,\n      width: \"1600\",\n      height: \"600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: toggleMode,\n      children: \"Toggle Mode\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 227,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true);\n}\n_s(Graph, \"6svObZ3T3m/cTS485F2jUDxrR8o=\");\n_c = Graph;\nexport default Graph;\n\n/*\n\n\nOk Here's what the fuck is happening. \n\nSo right now the lines get drawn but aren't stored anywhere. \n\nI need the data array to contain three items per point: \n    - price\n    - id\n    - class\n\nso the array should look like: \n\n    [[58, 0, 1], [50, 0, 1], [60, 1, 3]]\n\nPrice should be generated randomly for now. \nId will be unique for each section bounded by vertical lines\nClass will be generated randomly for now 0-k\n\n\n*/\nvar _c;\n$RefreshReg$(_c, \"Graph\");","map":{"version":3,"names":["useState","useEffect","useRef","jsxDEV","_jsxDEV","Fragment","_Fragment","Graph","dataFromCsv","_s","canvasRef","mode","setMode","verticalLines","setVerticalLines","initialData","Array","from","length","dataPoints","setDataPoints","adjustedData","getClickedId","event","canvas","current","rect","getBoundingClientRect","x","clientX","left","x_step","width","index","Math","floor","pointId","updateColorById","id","updatedPoints","map","point","addVeriticalLine","ctx","getContext","prevLines","newLines","sort","a","b","updatePointIds","newId","i","drawGraph","clearRect","height","lineWidth","forEach","price","color","prevX","prevPoint","prevPrice","prevId","strokeStyle","beginPath","moveTo","lineTo","stroke","line","linewidth","handleCanvasClick","toggleMode","test","console","log","document","addEventListener","key","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","onClick","_c","$RefreshReg$"],"sources":["/Users/simonsprouse/Desktop/Rev/TimeSeriesLabel/GitHubProject/TimeSeriesLabel/react-app/src/Graph.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react'\n\nfunction Graph(dataFromCsv) { \n\n    // Variables\n    const canvasRef = useRef(null);\n    const [mode, setMode] = useState(\"Split\");\n    const [verticalLines, setVerticalLines] = useState([]);\n    const initialData = Array.from({length: 300}, () => [0, 0, 0])\n    const [dataPoints, setDataPoints] = useState(initialData);\n\n    // Load data from prop\n    useEffect(() => { \n        const adjustedData = dataFromCsv['dataFromCsv'];\n        setDataPoints(adjustedData);\n    }, [dataFromCsv]);\n\n\n\n    /*\n    ------------------------\n            Edit Mode\n    ------------------------\n    */\n\n    function getClickedId(event) { \n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n        const x_step = canvas.width / (dataPoints.length - 1);\n        const index = Math.floor(x / x_step);\n        const pointId = dataPoints[index][1];\n\n        return pointId;\n    }\n\n    function updateColorById(id) { \n        const updatedPoints = dataPoints.map(point => {\n            const pointId = point[1];\n            if (pointId == id) { \n                return [point[0], point[1], point[2] + 1];\n            }\n            return point;\n        \n        });\n        setDataPoints(updatedPoints);\n    }\n\n    /*\n    ------------------------\n           Segment Mode\n    ------------------------\n    */\n\n\n    function addVeriticalLine(event) { \n        \n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        \n        const rect = canvas.getBoundingClientRect();\n        const x = event.clientX - rect.left;\n\n\n        setVerticalLines(prevLines => {\n            const newLines = [...prevLines, x].sort((a, b) => a - b);\n            updatePointIds(newLines);\n            return newLines;\n        });\n\n    }\n\n    function updatePointIds(verticalLines) { \n        const canvas = canvasRef.current;\n        const x_step = canvas.width / (dataPoints.length - 1);\n\n        // dataPoints.forEach(point => console.log(point));\n\n        const updatedPoints = dataPoints.map((point, index) => { \n            const x = x_step * index; // x pos on graph\n            let newId = 0;\n\n            for (let i = 0; i < verticalLines.length; i++) {\n                if (x > verticalLines[i]) { \n                    newId = i + 1;\n                }\n                else { \n                    break;\n                }\n            }\n\n            return [point[0], newId, point[2]];\n        });\n\n        // updatedPoints.forEach(point => console.log(point));\n\n        setDataPoints(updatedPoints);\n\n    }\n\n    /*\n    ------------------------\n            Rendering\n    ------------------------\n    */\n\n\n    function drawGraph() {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n\n        const x_step = canvas.width / (dataPoints.length - 1);\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.lineWidth = 3;\n\n        // draw datapoints graph\n        dataPoints.forEach((point, index) => { \n\n\n            const x = index * x_step;\n            const price = canvas.height - point[0];\n            const id = point[1];\n            const color = point[2];\n\n            if (index > 0) { \n\n                \n                const prevX = (index - 1) * x_step;\n\n                const prevPoint = dataPoints[index - 1];\n                const prevPrice = canvas.height - prevPoint[0];\n                const prevId = prevPoint[1]\n\n\n                if (color % 4 == 0) {\n                    ctx.strokeStyle = \"blue\";\n                }\n                else if (color % 4 == 1) {\n                    ctx.strokeStyle = \"red\";\n                }\n                else if (color % 4 == 2) {\n                    ctx.strokeStyle = \"green\";\n                }\n                else if (color % 4 == 3) {\n                    ctx.strokeStyle = \"orange\";\n                }\n                \n                ctx.beginPath();\n                ctx.moveTo(prevX, prevPrice);\n                ctx.lineTo(x, price);\n                ctx.stroke();\n            }\n            \n        });\n\n\n        // draw vertical lines\n        verticalLines.forEach(line => {\n            \n            ctx.beginPath();\n            ctx.moveTo(line, 0);\n            ctx.lineTo(line, canvas.height);\n            ctx.strokeStyle = \"black\";\n            ctx.linewidth = 2;\n            ctx.stroke();\n        })\n    }\n\n\n    // draw graph\n    useEffect(() => { \n        // console.log(\"detected a change in dataPoints\");\n        drawGraph();\n    }, [verticalLines, dataPoints]);\n\n\n    /*\n    ------------------------\n                UX\n    ------------------------\n    */\n\n\n    function handleCanvasClick(event) { \n        if (mode == \"Split\") { \n            addVeriticalLine(event);\n        }\n        else if (mode == \"Edit\") { \n            const id = getClickedId(event);\n            updateColorById(id);\n        }\n    }\n\n\n    function toggleMode() { \n        if (mode == \"Split\") { \n            setMode(\"Edit\");\n        }\n        else { \n            setMode(\"Split\");\n        }\n\n        \n\n    }\n\n\n    function test() {\n        // dataFromCsv.forEach((point, index) => { \n        //     console.log(point, index);\n        // })\n        console.log(dataFromCsv['dataFromCsv']);\n    }\n\n    document.addEventListener(\"keydown\", (event) => { \n        if (event.key == \"Enter\") { \n            toggleMode();\n        }\n    })\n\n\n    return (\n        <>\n            <p>{mode == \"Split\" ? \"Segment Mode\" : \"Label Mode\"}</p>\n            <canvas id=\"graph\" ref={canvasRef} onClick={handleCanvasClick} width=\"1600\" height=\"600\"></canvas>\n            <button onClick={toggleMode}>Toggle Mode</button>\n            {/* <button onClick={test}>Test</button> */}\n        </>\n    )\n}\n\nexport default Graph;\n\n\n\n\n\n\n\n\n/*\n\n\nOk Here's what the fuck is happening. \n\nSo right now the lines get drawn but aren't stored anywhere. \n\nI need the data array to contain three items per point: \n    - price\n    - id\n    - class\n\nso the array should look like: \n\n    [[58, 0, 1], [50, 0, 1], [60, 1, 3]]\n\nPrice should be generated randomly for now. \nId will be unique for each section bounded by vertical lines\nClass will be generated randomly for now 0-k\n\n\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}